<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Clean Region</title>
    <script src="js/fabric.js"></script>
</head>
<body>
<div>
    <button onclick="addRegion()">添加区域</button>
    <button id="btnCompleteRegion" onclick="finishRegion()" disabled>完成</button>
    <button onclick="getRegion()">获取区域</button>
    <button onclick="getCircle()">获取圆点</button>
</div>
<div style="border: 1px solid gray;width: 500px">
    <canvas id="c" width="500" height="500"></canvas>
</div>
</body>
</html>
<style type="text/css">
    button {
        margin: 10px 20px;
    }
</style>
<script type="text/javascript">
    var deleteIcon = "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E%3Csvg version='1.1' id='Ebene_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='595.275px' height='595.275px' viewBox='200 215 230 470' xml:space='preserve'%3E%3Ccircle style='fill:%23F44336;' cx='299.76' cy='439.067' r='218.516'/%3E%3Cg%3E%3Crect x='267.162' y='307.978' transform='matrix(0.7071 -0.7071 0.7071 0.7071 -222.6202 340.6915)' style='fill:white;' width='65.545' height='262.18'/%3E%3Crect x='266.988' y='308.153' transform='matrix(0.7071 0.7071 -0.7071 0.7071 398.3889 -83.3116)' style='fill:white;' width='65.544' height='262.179'/%3E%3C/g%3E%3C/svg%3E";
    var deleteImg = document.createElement('img');
    deleteImg.src = deleteIcon;

    var addIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAuNJREFUWEfNlz9oE3EUx7/vYtNWi7pIUEQURwe1TVJ0sR1EEdtchnaw16KLioI66OBkRXBRcNL6DwRztcUOl1apBQcLItVcqlCok6CgRDQuWhtNSO7JVZPeJWnvlwQSb37v/T6/7/vze0eo8Uc1Ph/CADsOa2vdabQxSXvA7AfgIcDDIAJzHMRxgHSSpCeZhsbn07f3fhe5nCPAtq6H7pX17lMATgPYKBIUQIzBdxiNt6bV/Z+X81kWwHtI85MkDQDcLHhwvlmMiC5FQoGbS/kvCeDvGzvIhvGozINtbgy+GFWD/cViFQXw9o6dITauORw+aQZ2MX3NEHcT6MKyUktSR+R+5+N8mwIAv6LJDNKcbs7g9qganDTtvIrWRqBnjj4Gt0YfBCNWOxvA34KrnxLJua7KNl+fEmYnAIBeJ5LJXbMj3amsbX6QswCuOAcCygNYiHxOV+WrBQCtPeOrDUrNirZaBQCf0nXu5jf3DsRNiJwC/t7wPmZMiNzetKkAAGCc1AflGzYAX492GUTnqwIATOqq3G4HUMIvAOyuEgASyVS9WYy5FPiU8DsAWy0AC32ebTVRsHy7FmViPeHXsYI5kcYmfVj+uFgDSniOgaZsAGufl3t41q/YnCAiXyQUiFoUGP0J8KpqAYAlvz7YqS8C9ITfg7C5WilwpXnLy+HgB4sCWgQgn6jcFbUhgCT9aJoJ9c1bi/A6gBPVAGBgJqrK2+2DqMTnt0IFcuM4p0DL0adrpMT8WwAbRFSoACAmZaj51VDgi02Bf89qv9O7noUrFyB/ObG9hubQkPA7KqJCmQAxAw1e655YuJD0jh5n5gGnNJSzkBBRdyQUGFlyIbFMLpFUlLSSAaToamAw/2L/51KaU6KWa3kWoqY/JtZ87Twyvm5FKtUFQheAtqJFSphig+6yIY1ND3V8cyrkgjkg4mDaLKjicnuojjxsELkymXiibi5uznbRGFk7x3/DUgOWav8HEtBgMITdcBIAAAAASUVORK5CYII="
    var addImg = document.createElement('img');
    addImg.src = addIcon;
    const CIRCLE_RADIUS = 8

    let regionPoints = []
    let mouseDownOption = null
    let regionAdding = false
    let rid = `region-${new Date().getTime()}`;
    let selectionClearedTime = new Date()

    fabric.Object.prototype.originX = fabric.Object.prototype.originY = 'center';
    fabric.Object.prototype.transparentCorners = false;
    fabric.Object.prototype.cornerColor = 'blue';
    fabric.Object.prototype.cornerStyle = 'circle';
    fabric.Object.prototype.borderScaleFactor = 3//选中后的边框宽度
    fabric.Object.prototype.borderColor = '#0048ff'

    fabricCanvas = new fabric.Canvas('c', {
        selection: false
    });

    fabricCanvas.on('mouse:down', opt => {
        mouseDownOption = opt
    })
    fabricCanvas.on('mouse:up', opt => {
        //console.info(opt)
        if (mouseDownOption.target == null) { //未选中时再触发
            if (opt.pointer.x == mouseDownOption.pointer.x &&
                opt.pointer.y == mouseDownOption.pointer.y) {
                if (new Date().getTime() - selectionClearedTime.getTime() >= 100) {//处理取消选中
                    canvasMouseDown(opt)
                }
            }
        }
        mouseDownOption = null
    })

    fabricCanvas.on('object:moving', function (opt) {
        // 当前移动的元素
        //let target = e.target
        let obj = opt.target


        let canvasBoundaries = fabricCanvas.calcViewportBoundaries()

        let paddingLeft = obj.width / 2, paddingTop = obj.height / 2;

        if (obj.type == 'polygon') {
            paddingLeft += CIRCLE_RADIUS
            paddingTop += CIRCLE_RADIUS
        }

        let repair = false
        //检查是否移动出画布
        if (obj.left - paddingLeft < canvasBoundaries.tl.x) {
            obj.set({
                left: canvasBoundaries.tl.x + paddingLeft
            })
            repair = true
        }

        if (obj.left + paddingLeft > canvasBoundaries.br.x) {
            obj.set({
                left: canvasBoundaries.br.x - paddingLeft
            })
            repair = true
        }

        if (obj.top - paddingTop < canvasBoundaries.tl.y) {
            obj.set({
                top: canvasBoundaries.tl.y + paddingTop
            })
            repair = true
        }

        if (obj.top + paddingTop > canvasBoundaries.br.y) {
            obj.set({
                top: canvasBoundaries.br.y - paddingTop
            })
            repair = true
        }
        if (repair) {
            //console.info(repair)
            obj.setCoords()
        }
        if (obj.type == 'polygon') {
            //console.info(obj.points, obj.calcTransformMatrix())
            var matrix = obj.calcTransformMatrix();
            var transformedPoints = obj.points
                .map(function (p) {
                    return new fabric.Point(
                        p.x - obj.pathOffset.x,
                        p.y - obj.pathOffset.y);
                })
                .map(function (p) {
                    return fabric.util.transformPoint(p, matrix);
                });
            //console.info(transformedPoints, obj.points, obj)

            let points = obj.points // 获取多边形的点
            let cList = fabricCanvas.getObjects('circle').filter(item => item.rid == obj.rid).sort((a, b) => a.cid - b.cid);
            transformedPoints.forEach((item, index) => {
                points[index].x = item.x // 修改指定顶点的x坐标
                points[index].y = item.y // 修改指定定点的y坐标
                cList[index].set({
                    left: item.x,
                    top: item.y
                }).setCoords()
            })

            let centerPoint = getPolygonCenter(transformedPoints)
            fabricCanvas.getObjects('text').filter(item => item.rid == obj.rid)[0].set({
                left: centerPoint.x,
                top: centerPoint.y
            })
            fabricCanvas.renderAll() // 刷新画布
            obj._setPositionDimensions({})
        } else if (obj.tag == 'polygon-vertex') {
            adjustingPolygonPoint(obj, true)
        }
        //console.info(obj, obj._controlsVisibility)
    })

    fabricCanvas.on('selection:created', opt => {
        //console.info(opt.selected[0].type)
        if (opt.selected[0].type == 'polygon') {//circle

        }

        if (opt.selected[0].type == 'circle' && opt.selected[0].tag == 'polygon-vertex') {//circle 更新control x,y
            //console.info(opt.selected[0])
            setAddControlCoord(opt.selected[0])
        }
        //console.info(opt)
    })
    fabricCanvas.on('selection:updated', opt => {
        //console.info(opt)
        if (opt.selected[0].type == 'polygon') {

        }
        if (opt.deselected[0].type == 'polygon') {//circle

        }

        if (opt.selected[0].type == 'circle' && opt.selected[0].tag == 'polygon-vertex') {//circle 更新control x,y
            //console.info(opt.selected[0])
            setAddControlCoord(opt.selected[0])
        }
    })
    fabricCanvas.on('selection:cleared', opt => {
        if (opt.deselected && opt.deselected[0].type == 'polygon') {//circle

        }
        selectionClearedTime = new Date()
    })

    function setAddControlCoord(target) {
        let cList = fabricCanvas.getObjects('circle').filter(item => item.rid == target.rid).sort((a, b) => a.cid - b.cid);

        if (target._controlsVisibility.backwardAddControl) {
            let index1 = target.cid == cList.length - 1 ? 0 : target.cid + 1
            let newCoord = calcAddControlCoord(cList[index1], cList[target.cid])

            target.controls.backwardAddControl.x = newCoord.x
            target.controls.backwardAddControl.y = newCoord.y
        }
        if (target._controlsVisibility.forwardAddControl) {
            let index1 = target.cid == 0 ? cList.length - 1 : target.cid - 1
            let newCoord = calcAddControlCoord(cList[index1], cList[target.cid])

            target.controls.forwardAddControl.x = newCoord.x
            target.controls.forwardAddControl.y = newCoord.y
        }
    }

    function renderIcon(icon) {
        return function renderIcon(ctx, left, top, styleOverride, fabricObject) {
            var size = this.cornerSize;
            ctx.save();
            ctx.translate(left, top);
            ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle));
            ctx.drawImage(icon, -size / 2, -size / 2, size, size);
            ctx.restore();
            //console.info(arguments)
        }
    }

    function deleteObject(eventData, transform) {
        var target = transform.target;
        var canvas = target.canvas;
        if (target.type == 'circle' && target.completedPolygon &&
            canvas.getObjects('polygon').filter(item => item.rid == target.rid)[0].points.length == 3) {
            alert('删除失败：多边形至少3个点')
            return
        }
        if (confirm("确定删除吗?")) {
            if (target.type == 'polygon') {//删除多边形
                canvas.remove(target);
                canvas.getObjects('text').forEach(item => {
                    if (item.rid == target.rid) {
                        canvas.remove(item);
                    }
                })
                canvas.getObjects('circle').forEach(item => {
                    if (item.rid == target.rid) {
                        canvas.remove(item);
                    }
                })
            } else if (target.type == 'circle') {//删除圆
                if (target.completedPolygon) {//完成多边形
                    //删除原有的多边形
                    let orgPolygon = canvas.getObjects('polygon').filter(item => item.rid == target.rid)[0]
                    canvas.remove(orgPolygon)
                    let orgText = canvas.getObjects('text').filter(item => item.rid == target.rid)[0]
                    canvas.remove(orgText)
                    canvas.remove(target);
                    let newPoints = []
                    canvas.getObjects('circle').filter(item => item.rid == target.rid).sort((a, b) => a.cid - b.cid).forEach(item => {
                        //console.info(item.cid)
                        if (item.cid > target.cid) {
                            item.cid -= 1
                        }
                        newPoints.push({
                            x: item.left,
                            y: item.top
                        })
                    })
                    addPolygonToCanvas(newPoints, target.rid)
                    canvas.getObjects('circle').filter(item => item.rid == target.rid).forEach(item => {
                        item.bringToFront()
                    })
                    initCircleControlVisibility(target.rid, false)
                } else {
                    canvas.remove(target);
                    //删除tag: 'tempLine'& 重新连线,
                    let newP1 = null, newP2 = null;
                    fabricCanvas.getObjects('line').filter(item => item.tag == 'tempLine').forEach(item => {
                        if (item.x1 == target.left && item.y1 == target.top) {
                            //console.info(item)
                            canvas.remove(item);
                            newP2 = {
                                x: item.x2,
                                y: item.y2,
                                index: item.index
                            }
                        }
                        if (item.x2 == target.left && item.y2 == target.top) {
                            //console.info(item)
                            canvas.remove(item);
                            newP1 = {
                                x: item.x1,
                                y: item.y1,
                                index: item.index
                            }
                        }
                    })
                    if (newP1 && newP2) {
                        fabricCanvas.getObjects('line').filter(item => item.tag == 'tempLine' && item.index > newP2.index).sort((a, b) => a.index - b.index).forEach(item => {
                            item.index -= 1
                        })
                        addLine(newP1, newP2, newP1.index)
                    }
                    if (newP2 != null && newP1 == null) {//删除第一个时重新编号
                        fabricCanvas.getObjects('line').filter(item => item.tag == 'tempLine').sort((a, b) => a.index - b.index).forEach(item => {
                            item.index -= 1
                        })
                    }
                    // 删除对象的顶点 regionPoints
                    delete regionPoints.splice(target.cid, 1)
                    if (regionPoints.length < 3) {
                        document.getElementById('btnCompleteRegion').disabled = true
                    }

                    //重新对圆cid赋值
                    canvas.getObjects('circle').forEach(item => {
                        if (item.rid == target.rid && item.cid > target.cid) {
                            item.cid -= 1
                        }
                    })
                    initCircleControlVisibility(target.rid, true)
                }

                //console.info(target.completedPolygon, target.cid)
            }
            canvas.requestRenderAll();
        }
    }

    fabric.Polygon.prototype.controls = {}
    //fabric.Polygon.prototype.controls.mtr  = fabric.Object.prototype.controls.mtr
    fabric.Polygon.prototype.controls.deleteControl = new fabric.Control({
        x: 0.5,
        y: -0.5,
        offsetY: 16,
        cursorStyle: 'pointer',
        mouseUpHandler: deleteObject,
        render: renderIcon(deleteImg),
        cornerSize: 24
    });

    fabric.Circle.prototype.controls = {}
    //fabric.Polygon.prototype.controls.mtr  = fabric.Object.prototype.controls.mtr

    //添加顶点
    function addVertex(eventData, transform) {
        var target = transform.target;
        var canvas = target.canvas;
        //console.info(target.cid, target.rid, transform.corner)


        let p1, index, orgPolygon;
        if (target.completedPolygon) {
            orgPolygon = fabricCanvas.getObjects('polygon').filter(item => item.rid == target.rid)[0]
        }
        if (transform.corner == 'forwardAddControl') {
            if (orgPolygon) {
                p1 = orgPolygon.points[target.cid == 0 ? orgPolygon.points.length - 1 : target.cid - 1]
            } else {
                p1 = regionPoints[target.cid - 1]
            }
            index = target.cid
        } else if (transform.corner == 'backwardAddControl') {
            if (orgPolygon) {
                p1 = orgPolygon.points[target.cid == orgPolygon.points.length - 1 ? 0 : target.cid + 1]
            } else {
                p1 = regionPoints[target.cid + 1]
            }
            index = target.cid + 1
        }
        if (target.completedPolygon) {
            //删除原有的多边形
            let cp = calcCenterPoint(p1, orgPolygon.points[target.cid])
            canvas.remove(orgPolygon)
            let orgText = canvas.getObjects('text').filter(item => item.rid == target.rid)[0]
            canvas.remove(orgText)

            addCircle(cp, target.rid, true, index)

            let newPoints = []
            canvas.getObjects('circle').filter(item => item.rid == target.rid).sort((a, b) => a.cid - b.cid).forEach(item => {
                newPoints.push({
                    x: item.left,
                    y: item.top
                })
            })
            addPolygonToCanvas(newPoints, target.rid)
            canvas.getObjects('circle').filter(item => item.rid == target.rid).forEach(item => {
                item.bringToFront()
            })
            initCircleControlVisibility(target.rid, false)
        } else {
            let cp = calcCenterPoint(p1, regionPoints[target.cid])
            addCircle(cp, target.rid, false, index)
        }
    }

    function calcCenterPoint(p1, p2) {
        return {
            x: parseInt((p1.x + p2.x) / 2),
            y: parseInt((p1.y + p2.y) / 2) + 20
        }
    }

    /**
     * 选中多边形
     */
    function activePolygon(polygon) {

    }

    /**
     * 取消选中多边形
     */
    function deactivePolygon(polygon) {

    }

    /**
     * 调整多边形点
     */
    function adjustingPolygonPoint(target, setPD) {
        // 判断是多边形点
        if (target.tag == 'polygon-vertex') {
            let index = target.cid // 获取cid
            if (target.completedPolygon) {//已完成的多边形
                let polygon = fabricCanvas.getObjects('polygon').filter(item => item.rid == target.rid)[0]
                let points = polygon.points // 获取多边形的点
                points[index].x = target.left // 修改指定顶点的x坐标
                points[index].y = target.top // 修改指定定点的y坐标

                let centerPoint = getPolygonCenter(points)
                fabricCanvas.getObjects('text').filter(item => item.rid == target.rid)[0].set({
                    left: centerPoint.x,
                    top: centerPoint.y
                })
                fabricCanvas.renderAll() // 刷新画布
                if (setPD) {
                    polygon._setPositionDimensions({})
                }
                let newCoord = calcAddControlCoord(points[index == points.length - 1 ? 0 : index + 1], points[index])
                //console.info(newCoord)
                target.controls.backwardAddControl.x = newCoord.x
                target.controls.backwardAddControl.y = newCoord.y

                newCoord = calcAddControlCoord(points[index == 0 ? points.length - 1 : index - 1], points[index])
                //console.info(newCoord)
                target.controls.forwardAddControl.x = newCoord.x
                target.controls.forwardAddControl.y = newCoord.y

            } else {//创建中的多边形
                let tempLineList = fabricCanvas.getObjects('line').filter(item => item.tag == 'tempLine').sort((a, b) => a.index - b.index)
                regionPoints[index] = {
                    x: target.left,
                    y: target.top
                }
                if (tempLineList.length > 0) {
                    let prveLineIndex = index - 1
                    if (prveLineIndex >= 0) {//前一条线
                        tempLineList[prveLineIndex].set({
                            x2: target.left,
                            y2: target.top
                        }).setCoords()
                    }
                    if (index != tempLineList.length) {//后一条线
                        tempLineList[index].set({
                            x1: target.left,
                            y1: target.top
                        }).setCoords()
                    }
                }
                //
                if (target._controlsVisibility.backwardAddControl) {
                    let newCoord = calcAddControlCoord(regionPoints[index + 1], regionPoints[index])
                    //console.info(newCoord)
                    target.controls.backwardAddControl.x = newCoord.x
                    target.controls.backwardAddControl.y = newCoord.y
                }
                if (target._controlsVisibility.forwardAddControl) {
                    let newCoord = calcAddControlCoord(regionPoints[index - 1], regionPoints[index])
                    //console.info(newCoord)
                    target.controls.forwardAddControl.x = newCoord.x
                    target.controls.forwardAddControl.y = newCoord.y
                }
            }
        }
    }

    function addRegion() {
        if (regionPoints.length != 0) {
            if (confirm("有未完成的区域，新建后将废弃此区域数据?")) {
                let unFinishCircleList = fabricCanvas.getObjects('circle').filter(item => !item.completedPolygon)
                regionPoints = []
                regionAdding = true
                document.getElementById('btnCompleteRegion').disabled = true

                //删除绘制未完成的object
                unFinishCircleList.forEach(item => {
                    fabricCanvas.remove(item)
                })
                fabricCanvas.getObjects('line').forEach(item => {
                    if (item.tag == 'tempLine') {
                        fabricCanvas.remove(item)
                    }
                })
            }
        } else {
            regionAdding = true
        }

    }

    function finishRegion() {
        document.getElementById('btnCompleteRegion').disabled = true
        regionAdding = false
        //删除临时线
        fabricCanvas.getObjects('line').forEach(item => {
            if (item.tag == 'tempLine') {
                fabricCanvas.remove(item)
            }
        })
        //添加polyline
        addPolygonToCanvas(regionPoints, rid)

        let cList = fabricCanvas.getObjects('circle').filter(item => item.rid == rid).sort((a, b) => a.cid - b.cid);

        cList.forEach(item => {
            item.set({
                completedPolygon: true,//完成多边形
            })
            if (!item._controlsVisibility.forwardAddControl) {
                item.setControlsVisibility({
                    forwardAddControl: true
                })
                let newCoord = calcAddControlCoord(cList[item.cid == 0 ? (cList.length - 1) : (item.cid - 1)], cList[item.cid])
                //console.info(newCoord)
                item.controls.forwardAddControl.y = newCoord.y
                item.controls.forwardAddControl.x = newCoord.x
            }
            if (!item._controlsVisibility.backwardAddControl) {
                item.setControlsVisibility({
                    backwardAddControl: true
                })
                let newCoord = calcAddControlCoord(cList[item.cid == cList.length - 1 ? 0 : item.cid + 1], cList[item.cid])
                item.controls.backwardAddControl.y = newCoord.y
                item.controls.backwardAddControl.x = newCoord.x
            }
            item.bringToFront()
        })
        regionPoints = []
        rid = `region-${new Date().getTime()}`
    }

    function addPolygonToCanvas(vertexList, regionId) {
        //添加polyline
        // 多边形
        const polygon = new fabric.Polygon(
            vertexList, // 顶点坐标集
            {
                fill: '#d5ece0', // 填充红色
                stroke: 'black', // 边框黑色
                strokeWidth: 1, // 边框粗细
                objectCaching: false, // 当“true”时，对象缓存在另一个画布上。当“false”时，除非必要(clipPath)默认为 true，否则不缓存对象。默认是true
                //selectable: false, // 禁止选中
                //evented: false, // 当设置为“false”时，对象不能成为事件的目标。所有事件都会通过它传播。
                rid: regionId,
                // lockMovementX: true,
                // lockMovementY: true,
                lockRotation: true,
                lockScalingX: true,
                lockScalingY: true,
            }
        )
        fabricCanvas.add(polygon)

        let centerPoint = getPolygonCenter(vertexList)
        //console.info(centerPoint)
        //添加命名
        let text = new fabric.Text('区域' + regionId.substring(regionId.length - 3, regionId.length), {
            left: centerPoint.x,
            top: centerPoint.y,
            fontSize: 16,
            selectable: false,
            evented: false,
            rid: regionId,
        })
        fabricCanvas.add(text)
    }

    function addCircle(p, regionId, completedPolygon, spliceIndex) {
        let cid;
        if (spliceIndex != null) {
            if (!completedPolygon) {
                regionPoints.splice(spliceIndex, 0, p)
            }
            cid = spliceIndex
            //纠正后续cid
            fabricCanvas.getObjects('circle').filter(item => item.rid == regionId && item.cid >= spliceIndex).sort((a, b) => a.cid - b.cid).forEach(item => {
                item.cid += 1
            });
            //console.info(regionPoints)
        } else {
            regionPoints.push(p)
            cid = regionPoints.length - 1
        }
        let cc = new fabric.Circle({
            left: p.x,
            top: p.y,
            strokeWidth: 3,
            radius: CIRCLE_RADIUS,
            fill: '#fff',
            stroke: '#666',
            lockRotation: true,
            lockScalingX: true,
            lockScalingY: true,
            //transparentCorners: true,
            cornerStyle: 'rect',
            rid: regionId,
            tag: 'polygon-vertex',
            cid: cid,
            completedPolygon: completedPolygon//完成多边形
        })
        cc.controls = {
            deleteControl: new fabric.Control({
                x: 0,
                y: 0.4,
                offsetY: 16,
                cursorStyle: 'pointer',
                mouseUpHandler: deleteObject,
                render: renderIcon(deleteImg),
                cornerSize: 24
            }),
            backwardAddControl: new fabric.Control({
                x: 1.2,
                y: 0,
                cursorStyle: 'pointer',
                mouseUpHandler: addVertex,
                render: renderIcon(addImg),
                cornerSize: 24
            }),
            forwardAddControl: new fabric.Control({//Forward backward 向前添加
                x: -1.2,
                y: 0,
                cursorStyle: 'pointer',
                mouseUpHandler: addVertex,
                render: renderIcon(addImg),
                cornerSize: 24
            })
        }
        fabricCanvas.add(cc)
        if (!completedPolygon) {
            initCircleControlVisibility(regionId, true)
            if (regionPoints.length >= 3) {
                document.getElementById('btnCompleteRegion').disabled = false
            }
            if (regionPoints.length >= 2) {
                if (spliceIndex != null) {
                    //删除旧templine线
                    fabricCanvas.getObjects('line').filter(item => item.tag == 'tempLine' && item.index == spliceIndex - 1).forEach(item => {
                        fabricCanvas.remove(item)
                    })

                    //重新排序
                    fabricCanvas.getObjects('line').filter(item => item.tag == 'tempLine' && item.index >= spliceIndex).sort((a, b) => a.index - b.index).forEach(item => {
                        item.index++
                    })
                    //添加新线
                    addLine(regionPoints[spliceIndex - 1], regionPoints[spliceIndex], spliceIndex - 1)
                    addLine(regionPoints[spliceIndex], regionPoints[spliceIndex + 1], spliceIndex)

                } else {
                    addLine(regionPoints[regionPoints.length - 2], p, null)
                }
            }
        } else {
            cc.setControlsVisibility({
                forwardAddControl: true,
                backwardAddControl: true
            })
        }
    }

    //初始化圆圈contorl的显示隐藏
    function initCircleControlVisibility(regionId, checkVisiblity) {
        let cList = fabricCanvas.getObjects('circle').filter(item => item.rid == regionId).sort((a, b) => a.cid - b.cid);
        cList.forEach((item, index) => {
            if (checkVisiblity) {
                item.setControlsVisibility({
                    forwardAddControl: index != 0,
                    backwardAddControl: index != cList.length - 1
                })
            }
            if (index != cList.length - 1) {//向后
                let newCoord = calcAddControlCoord(cList[index + 1], cList[index])
                item.controls.backwardAddControl.y = newCoord.y
                item.controls.backwardAddControl.x = newCoord.x
            }
            if (index > 0) {//向前
                let newCoord = calcAddControlCoord(cList[index - 1], cList[index])
                item.controls.forwardAddControl.y = newCoord.y
                item.controls.forwardAddControl.x = newCoord.x
            }
        })
    }

    function calcAddControlCoord(p1, p2) {
        //console.info(p1, p2)
        let diffX, diffY;
        if (p1.x) {
            diffX = p1.x - p2.x
            diffY = p1.y - p2.y
        } else {
            diffX = p1.left - p2.left
            diffY = p1.top - p2.top
        }
        let _tan = Math.atan(diffX / diffY)
        let gamma = Math.round(Math.abs(_tan) * 180 / Math.PI)
        let sin = Math.sin(gamma * Math.PI / 180)
        let cos = Math.cos(gamma * Math.PI / 180)
        const c = 2.5
        let x = parseInt(c * sin * 10) / 10, y = parseInt(c * cos * 10) / 10
        //console.info(gamma, sin, x, y)
        if (diffX < 0) {
            x = -x
        }
        if (diffY < 0) {
            y = -y
        }
        return {x, y}
    }

    function addLine(p1, p2, index) {
        if (index == null) {
            index = fabricCanvas.getObjects('line').filter(item => item.tag == 'tempLine').length
        }
        let _line = new fabric.Line([p1.x, p1.y,
            p2.x, p2.y
        ], {
            stroke: 'black',
            selectable: false,
            tag: 'tempLine',
            index: index,
            evented: false,
        })
        fabricCanvas.add(_line)
    }

    function canvasMouseDown(opt) {
        let point = fabricCanvas.getPointer(opt.e)
        //console.info(point, point.x, point.y)
        if (regionAdding) {
            addCircle(point, rid, false, null)
        }
    }

    /**
     * 获取多边形中心点
     * @param {Point[]} points 点坐标数组 [{x:0,y:0}...]
     */
    function getPolygonCenter(points) {
        if (!Array.isArray(points) || points.length < 3) {
            console.error("多边形坐标集合不能少于3个");
            return;
        }
        const result = {x: 0, y: 0};
        points.forEach((p) => {
            result.x += p.x;
            result.y += p.y;
        });
        result.x /= points.length;
        result.y /= points.length;
        return result;
    }

    function getRegion() {
        fabricCanvas.getObjects('polygon').forEach(item => {
            console.info(item)
        })
    }

    function getCircle() {
        fabricCanvas.getObjects('circle').forEach(item => {
            console.info(item)
        })
    }

</script>