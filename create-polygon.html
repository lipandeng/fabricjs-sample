<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Clean Region</title>
    <script src="js/fabric.js"></script>
</head>
<body>
<div style="display: flex">
    <div class="left-cate">
        <div class="active" onclick="regionCateClick(0,this)">区域管理</div>
        <div onclick="regionCateClick(1,this)">路径管理</div>
    </div>
    <div>
        <div class="top-group">
            <div>
                <button onclick="addRegion()">添加区域</button>
                <button id="btnCompleteRegion" onclick="finishRegion()" disabled>完成</button>
            </div>
            <div class="dis-none">
                <button onclick="addArcuateLine()">添加弓型线</button>
            </div>
        </div>
        <div style="border: 1px solid gray;width: 500px">
            <canvas id="c" width="500" height="500"></canvas>
        </div>
        <div class="region-outer" id="region-outer" style="display: none">
            <div class="region-title">区域列表:</div>
            <ul id="region-ul">

            </ul>
        </div>
    </div>
</div>

</body>
</html>
<style type="text/css">
    button {
        margin: 10px 20px;
    }

    .left-cate {
        padding-top: 20px;
        width: 100px;
        border: 1px solid greenyellow;
        margin-right: 10px;
    }

    .dis-none {
        display: none;
    }

    .left-cate div {
        height: 50px;
        line-height: 50px;
        padding-left: 10px;
        cursor: pointer;
        border: 1px solid #31c5af;
    }

    .left-cate .active {
        background-color: #aeffc8;
    }

    .top-group {
        border: 1px solid #6d966d;
        margin-bottom: 10px;
    }

    .region-outer {
        margin-top: 20px
    }

    .region-title {
        font-weight: bold;
    }


    .region-outer ul {
        width: 200px;
        padding-left: 5px
    }

    .region-outer li {
        list-style: none;
        height: 30px;
        line-height: 30px;
        border-bottom: 1px solid gray;
        cursor: pointer;
    }

    .region-outer .active {
        background-color: #26ff90;
    }
</style>
<script type="text/javascript">

    var starImg = "data:image/png;base64,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"
    var endImg = "data:image/png;base64,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"

    var deleteIcon = "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E%3Csvg version='1.1' id='Ebene_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='595.275px' height='595.275px' viewBox='200 215 230 470' xml:space='preserve'%3E%3Ccircle style='fill:%23F44336;' cx='299.76' cy='439.067' r='218.516'/%3E%3Cg%3E%3Crect x='267.162' y='307.978' transform='matrix(0.7071 -0.7071 0.7071 0.7071 -222.6202 340.6915)' style='fill:white;' width='65.545' height='262.18'/%3E%3Crect x='266.988' y='308.153' transform='matrix(0.7071 0.7071 -0.7071 0.7071 398.3889 -83.3116)' style='fill:white;' width='65.544' height='262.179'/%3E%3C/g%3E%3C/svg%3E";
    var deleteImg = document.createElement('img');
    deleteImg.src = deleteIcon;

    var addIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAuNJREFUWEfNlz9oE3EUx7/vYtNWi7pIUEQURwe1TVJ0sR1EEdtchnaw16KLioI66OBkRXBRcNL6DwRztcUOl1apBQcLItVcqlCok6CgRDQuWhtNSO7JVZPeJWnvlwQSb37v/T6/7/vze0eo8Uc1Ph/CADsOa2vdabQxSXvA7AfgIcDDIAJzHMRxgHSSpCeZhsbn07f3fhe5nCPAtq6H7pX17lMATgPYKBIUQIzBdxiNt6bV/Z+X81kWwHtI85MkDQDcLHhwvlmMiC5FQoGbS/kvCeDvGzvIhvGozINtbgy+GFWD/cViFQXw9o6dITauORw+aQZ2MX3NEHcT6MKyUktSR+R+5+N8mwIAv6LJDNKcbs7g9qganDTtvIrWRqBnjj4Gt0YfBCNWOxvA34KrnxLJua7KNl+fEmYnAIBeJ5LJXbMj3amsbX6QswCuOAcCygNYiHxOV+WrBQCtPeOrDUrNirZaBQCf0nXu5jf3DsRNiJwC/t7wPmZMiNzetKkAAGCc1AflGzYAX492GUTnqwIATOqq3G4HUMIvAOyuEgASyVS9WYy5FPiU8DsAWy0AC32ebTVRsHy7FmViPeHXsYI5kcYmfVj+uFgDSniOgaZsAGufl3t41q/YnCAiXyQUiFoUGP0J8KpqAYAlvz7YqS8C9ITfg7C5WilwpXnLy+HgB4sCWgQgn6jcFbUhgCT9aJoJ9c1bi/A6gBPVAGBgJqrK2+2DqMTnt0IFcuM4p0DL0adrpMT8WwAbRFSoACAmZaj51VDgi02Bf89qv9O7noUrFyB/ObG9hubQkPA7KqJCmQAxAw1e655YuJD0jh5n5gGnNJSzkBBRdyQUGFlyIbFMLpFUlLSSAaToamAw/2L/51KaU6KWa3kWoqY/JtZ87Twyvm5FKtUFQheAtqJFSphig+6yIY1ND3V8cyrkgjkg4mDaLKjicnuojjxsELkymXiibi5uznbRGFk7x3/DUgOWav8HEtBgMITdcBIAAAAASUVORK5CYII="
    var addImg = document.createElement('img');
    addImg.src = addIcon;
    const CIRCLE_RADIUS = 8;
    let currentActionType = 0;//0区域管理，1路径管理

    let regionPoints = []
    let mouseDownOption = null
    let regionAdding = false, arcuateLineAdding = false//弓形线;
    const POLYGON_FILL = '#d5ece0', ACTIVE_POLYGON_FILL = '#9ec6d5'
    //清洁宽度//60cm = 12px 5cm
    var cleanWidth = 12
    let rid = `region-${new Date().getTime()}`;
    let selectionClearedTime = new Date()

    fabric.Object.prototype.originX = fabric.Object.prototype.originY = 'center';
    fabric.Object.prototype.transparentCorners = false;
    fabric.Object.prototype.cornerColor = 'blue';
    fabric.Object.prototype.cornerStyle = 'circle';
    fabric.Object.prototype.borderScaleFactor = 3//选中后的边框宽度
    fabric.Object.prototype.borderColor = '#0048ff'

    fabricCanvas = new fabric.Canvas('c', {
        selection: false
    });

    fabricCanvas.on('mouse:down', opt => {
        mouseDownOption = opt
    })
    fabricCanvas.on('mouse:up', opt => {
        //console.info(opt)
        if (opt.pointer.x == mouseDownOption.pointer.x &&
            opt.pointer.y == mouseDownOption.pointer.y) {
            if (new Date().getTime() - selectionClearedTime.getTime() >= 100) {//处理取消选中
                canvasMouseDown(opt)
            }
        }
        mouseDownOption = null
    })

    fabricCanvas.on('object:moving', function (opt) {
        // 当前移动的元素
        //let target = e.target
        let obj = opt.target


        let canvasBoundaries = fabricCanvas.calcViewportBoundaries()

        let paddingLeft = obj.width / 2, paddingTop = obj.height / 2;

        if (obj.type == 'polygon') {
            paddingLeft += CIRCLE_RADIUS
            paddingTop += CIRCLE_RADIUS
        }

        let repair = false
        //检查是否移动出画布
        if (obj.left - paddingLeft < canvasBoundaries.tl.x) {
            obj.set({
                left: canvasBoundaries.tl.x + paddingLeft
            })
            repair = true
        }

        if (obj.left + paddingLeft > canvasBoundaries.br.x) {
            obj.set({
                left: canvasBoundaries.br.x - paddingLeft
            })
            repair = true
        }

        if (obj.top - paddingTop < canvasBoundaries.tl.y) {
            obj.set({
                top: canvasBoundaries.tl.y + paddingTop
            })
            repair = true
        }

        if (obj.top + paddingTop > canvasBoundaries.br.y) {
            obj.set({
                top: canvasBoundaries.br.y - paddingTop
            })
            repair = true
        }
        if (repair) {
            //console.info(repair)
            obj.setCoords()
        }
        if (obj.type == 'polygon') {
            //console.info(obj.points, obj.calcTransformMatrix())
            var matrix = obj.calcTransformMatrix();
            var transformedPoints = obj.points
                .map(function (p) {
                    return new fabric.Point(
                        p.x - obj.pathOffset.x,
                        p.y - obj.pathOffset.y);
                })
                .map(function (p) {
                    return fabric.util.transformPoint(p, matrix);
                });
            //console.info(transformedPoints, obj.points, obj)

            let points = obj.points // 获取多边形的点
            let cList = fabricCanvas.getObjects('circle').filter(item => item.rid == obj.rid).sort((a, b) => a.cid - b.cid);
            transformedPoints.forEach((item, index) => {
                points[index].x = item.x // 修改指定顶点的x坐标
                points[index].y = item.y // 修改指定定点的y坐标
                cList[index].set({
                    left: item.x,
                    top: item.y
                }).setCoords()
            })

            let centerPoint = getPolygonCenter(transformedPoints)
            fabricCanvas.getObjects('text').filter(item => item.rid == obj.rid)[0].set({
                left: centerPoint.x,
                top: centerPoint.y
            })
            fabricCanvas.renderAll() // 刷新画布
            obj._setPositionDimensions({})
        } else if (obj.tag == 'polygon-vertex') {
            adjustingPolygonPoint(obj, true)
        }
        //console.info(obj, obj._controlsVisibility)
    })

    fabricCanvas.on('selection:created', opt => {
        //console.info(opt.selected[0].type)
        if (opt.selected[0].type == 'polygon') {//circle

        }

        if (opt.selected[0].type == 'circle' && opt.selected[0].tag == 'polygon-vertex') {//circle 更新control x,y
            //console.info(opt.selected[0])
            setAddControlCoord(opt.selected[0])
        }
        //console.info(opt)
    })
    fabricCanvas.on('selection:updated', opt => {
        //console.info(opt)
        if (opt.selected[0].type == 'polygon') {

        }
        if (opt.deselected[0].type == 'polygon') {//circle

        }

        if (opt.selected[0].type == 'circle' && opt.selected[0].tag == 'polygon-vertex') {//circle 更新control x,y
            //console.info(opt.selected[0])
            setAddControlCoord(opt.selected[0])
        }
    })
    fabricCanvas.on('selection:cleared', opt => {
        if (opt.deselected && opt.deselected[0].type == 'polygon') {//circle

        }
        selectionClearedTime = new Date()
    })

    function setAddControlCoord(target) {
        let cList = fabricCanvas.getObjects('circle').filter(item => item.rid == target.rid).sort((a, b) => a.cid - b.cid);

        if (target._controlsVisibility.backwardAddControl) {
            let index1 = target.cid == cList.length - 1 ? 0 : target.cid + 1
            let newCoord = calcAddControlCoord(cList[index1], cList[target.cid])

            target.controls.backwardAddControl.x = newCoord.x
            target.controls.backwardAddControl.y = newCoord.y
        }
        if (target._controlsVisibility.forwardAddControl) {
            let index1 = target.cid == 0 ? cList.length - 1 : target.cid - 1
            let newCoord = calcAddControlCoord(cList[index1], cList[target.cid])

            target.controls.forwardAddControl.x = newCoord.x
            target.controls.forwardAddControl.y = newCoord.y
        }
    }

    function renderIcon(icon) {
        return function renderIcon(ctx, left, top, styleOverride, fabricObject) {
            var size = this.cornerSize;
            ctx.save();
            ctx.translate(left, top);
            ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle));
            ctx.drawImage(icon, -size / 2, -size / 2, size, size);
            ctx.restore();
            //console.info(arguments)
        }
    }

    function deleteObject(eventData, transform) {
        var target = transform.target;
        var canvas = target.canvas;
        if (target.type == 'circle' && target.completedPolygon &&
            canvas.getObjects('polygon').filter(item => item.rid == target.rid)[0].points.length == 3) {
            alert('删除失败：多边形至少3个点')
            return
        }
        if (confirm("确定删除吗?")) {
            if (target.type == 'polygon') {//删除多边形
                canvas.remove(target);
                canvas.getObjects('text').forEach(item => {
                    if (item.rid == target.rid) {
                        canvas.remove(item);
                    }
                })
                canvas.getObjects('circle').forEach(item => {
                    if (item.rid == target.rid) {
                        canvas.remove(item);
                    }
                })
            } else if (target.type == 'circle' && target.tag == 'polygon-vertex') {//删除圆
                if (target.completedPolygon) {//完成多边形
                    //删除原有的多边形
                    let orgPolygon = canvas.getObjects('polygon').filter(item => item.rid == target.rid)[0]
                    canvas.remove(orgPolygon)
                    let orgText = canvas.getObjects('text').filter(item => item.rid == target.rid)[0]
                    canvas.remove(orgText)
                    canvas.remove(target);
                    let newPoints = []
                    canvas.getObjects('circle').filter(item => item.rid == target.rid).sort((a, b) => a.cid - b.cid).forEach(item => {
                        //console.info(item.cid)
                        if (item.cid > target.cid) {
                            item.cid -= 1
                        }
                        newPoints.push({
                            x: item.left,
                            y: item.top
                        })
                    })
                    addPolygonToCanvas(newPoints, target.rid)
                    canvas.getObjects('circle').filter(item => item.rid == target.rid).forEach(item => {
                        item.bringToFront()
                    })
                    initCircleControlVisibility(target.rid, false)
                } else {
                    canvas.remove(target);
                    //删除tag: 'tempLine'& 重新连线,
                    let newP1 = null, newP2 = null;
                    fabricCanvas.getObjects('line').filter(item => item.tag == 'tempLine').forEach(item => {
                        if (item.x1 == target.left && item.y1 == target.top) {
                            //console.info(item)
                            canvas.remove(item);
                            newP2 = {
                                x: item.x2,
                                y: item.y2,
                                index: item.index
                            }
                        }
                        if (item.x2 == target.left && item.y2 == target.top) {
                            //console.info(item)
                            canvas.remove(item);
                            newP1 = {
                                x: item.x1,
                                y: item.y1,
                                index: item.index
                            }
                        }
                    })
                    if (newP1 && newP2) {
                        fabricCanvas.getObjects('line').filter(item => item.tag == 'tempLine' && item.index > newP2.index).sort((a, b) => a.index - b.index).forEach(item => {
                            item.index -= 1
                        })
                        addLine(newP1, newP2, newP1.index)
                    }
                    if (newP2 != null && newP1 == null) {//删除第一个时重新编号
                        fabricCanvas.getObjects('line').filter(item => item.tag == 'tempLine').sort((a, b) => a.index - b.index).forEach(item => {
                            item.index -= 1
                        })
                    }
                    // 删除对象的顶点 regionPoints
                    delete regionPoints.splice(target.cid, 1)
                    if (regionPoints.length < 3) {
                        document.getElementById('btnCompleteRegion').disabled = true
                    }

                    //重新对圆cid赋值
                    canvas.getObjects('circle').forEach(item => {
                        if (item.rid == target.rid && item.cid > target.cid) {
                            item.cid -= 1
                        }
                    })
                    initCircleControlVisibility(target.rid, true)
                }

                //console.info(target.completedPolygon, target.cid)
            } else if (target.type == 'circle' && target.tag == 'arcuate-point') {//删除圆
                console.info('dd')
                canvas.remove(target);
            }
            canvas.requestRenderAll();
        }
    }

    fabric.Polygon.prototype.controls = {}
    //fabric.Polygon.prototype.controls.mtr  = fabric.Object.prototype.controls.mtr
    fabric.Polygon.prototype.controls.deleteControl = new fabric.Control({
        x: 0.5,
        y: -0.5,
        offsetY: 16,
        cursorStyle: 'pointer',
        mouseUpHandler: deleteObject,
        render: renderIcon(deleteImg),
        cornerSize: 24
    });

    fabric.Circle.prototype.controls = {}
    //fabric.Polygon.prototype.controls.mtr  = fabric.Object.prototype.controls.mtr

    //添加顶点
    function addVertex(eventData, transform) {
        var target = transform.target;
        var canvas = target.canvas;
        //console.info(target.cid, target.rid, transform.corner)


        let p1, index, orgPolygon;
        if (target.completedPolygon) {
            orgPolygon = fabricCanvas.getObjects('polygon').filter(item => item.rid == target.rid)[0]
        }
        if (transform.corner == 'forwardAddControl') {
            if (orgPolygon) {
                p1 = orgPolygon.points[target.cid == 0 ? orgPolygon.points.length - 1 : target.cid - 1]
            } else {
                p1 = regionPoints[target.cid - 1]
            }
            index = target.cid
        } else if (transform.corner == 'backwardAddControl') {
            if (orgPolygon) {
                p1 = orgPolygon.points[target.cid == orgPolygon.points.length - 1 ? 0 : target.cid + 1]
            } else {
                p1 = regionPoints[target.cid + 1]
            }
            index = target.cid + 1
        }
        if (target.completedPolygon) {
            //删除原有的多边形
            let cp = calcCenterPoint(p1, orgPolygon.points[target.cid])
            canvas.remove(orgPolygon)
            let orgText = canvas.getObjects('text').filter(item => item.rid == target.rid)[0]
            canvas.remove(orgText)

            addCircle(cp, target.rid, true, index)

            let newPoints = []
            canvas.getObjects('circle').filter(item => item.rid == target.rid).sort((a, b) => a.cid - b.cid).forEach(item => {
                newPoints.push({
                    x: item.left,
                    y: item.top
                })
            })
            addPolygonToCanvas(newPoints, target.rid)
            canvas.getObjects('circle').filter(item => item.rid == target.rid).forEach(item => {
                item.bringToFront()
            })
            initCircleControlVisibility(target.rid, false)
        } else {
            let cp = calcCenterPoint(p1, regionPoints[target.cid])
            addCircle(cp, target.rid, false, index)
        }
    }

    function calcCenterPoint(p1, p2) {
        return {
            x: parseInt((p1.x + p2.x) / 2),
            y: parseInt((p1.y + p2.y) / 2) + 20
        }
    }

    /**
     * 选中多边形
     */
    function activePolygon(polygon) {

    }

    /**
     * 取消选中多边形
     */
    function deactivePolygon(polygon) {

    }

    /**
     * 调整多边形点
     */
    function adjustingPolygonPoint(target, setPD) {
        // 判断是多边形点
        if (target.tag == 'polygon-vertex') {
            let index = target.cid // 获取cid
            if (target.completedPolygon) {//已完成的多边形
                let polygon = fabricCanvas.getObjects('polygon').filter(item => item.rid == target.rid)[0]
                let points = polygon.points // 获取多边形的点
                points[index].x = target.left // 修改指定顶点的x坐标
                points[index].y = target.top // 修改指定定点的y坐标

                let centerPoint = getPolygonCenter(points)
                fabricCanvas.getObjects('text').filter(item => item.rid == target.rid)[0].set({
                    left: centerPoint.x,
                    top: centerPoint.y
                })
                fabricCanvas.renderAll() // 刷新画布
                if (setPD) {
                    polygon._setPositionDimensions({})
                }
                let newCoord = calcAddControlCoord(points[index == points.length - 1 ? 0 : index + 1], points[index])
                //console.info(newCoord)
                target.controls.backwardAddControl.x = newCoord.x
                target.controls.backwardAddControl.y = newCoord.y

                newCoord = calcAddControlCoord(points[index == 0 ? points.length - 1 : index - 1], points[index])
                //console.info(newCoord)
                target.controls.forwardAddControl.x = newCoord.x
                target.controls.forwardAddControl.y = newCoord.y

            } else {//创建中的多边形
                let tempLineList = fabricCanvas.getObjects('line').filter(item => item.tag == 'tempLine').sort((a, b) => a.index - b.index)
                regionPoints[index] = {
                    x: target.left,
                    y: target.top
                }
                if (tempLineList.length > 0) {
                    let prveLineIndex = index - 1
                    if (prveLineIndex >= 0) {//前一条线
                        tempLineList[prveLineIndex].set({
                            x2: target.left,
                            y2: target.top
                        }).setCoords()
                    }
                    if (index != tempLineList.length) {//后一条线
                        tempLineList[index].set({
                            x1: target.left,
                            y1: target.top
                        }).setCoords()
                    }
                }
                //
                if (target._controlsVisibility.backwardAddControl) {
                    let newCoord = calcAddControlCoord(regionPoints[index + 1], regionPoints[index])
                    //console.info(newCoord)
                    target.controls.backwardAddControl.x = newCoord.x
                    target.controls.backwardAddControl.y = newCoord.y
                }
                if (target._controlsVisibility.forwardAddControl) {
                    let newCoord = calcAddControlCoord(regionPoints[index - 1], regionPoints[index])
                    //console.info(newCoord)
                    target.controls.forwardAddControl.x = newCoord.x
                    target.controls.forwardAddControl.y = newCoord.y
                }
            }
        }
    }

    function addRegion() {
        if (regionPoints.length != 0) {
            if (confirm("有未完成的区域，新建后将废弃此区域数据?")) {
                let unFinishCircleList = fabricCanvas.getObjects('circle').filter(item => !item.completedPolygon)
                regionPoints = []
                regionAdding = true
                document.getElementById('btnCompleteRegion').disabled = true

                //删除绘制未完成的object
                unFinishCircleList.forEach(item => {
                    fabricCanvas.remove(item)
                })
                fabricCanvas.getObjects('line').forEach(item => {
                    if (item.tag == 'tempLine') {
                        fabricCanvas.remove(item)
                    }
                })
            }
        } else {
            regionAdding = true
        }

    }

    function finishRegion() {
        document.getElementById('btnCompleteRegion').disabled = true
        regionAdding = false
        //删除临时线
        fabricCanvas.getObjects('line').forEach(item => {
            if (item.tag == 'tempLine') {
                fabricCanvas.remove(item)
            }
        })
        //添加polyline
        addPolygonToCanvas(regionPoints, rid)

        let cList = fabricCanvas.getObjects('circle').filter(item => item.rid == rid).sort((a, b) => a.cid - b.cid);

        cList.forEach(item => {
            item.set({
                completedPolygon: true,//完成多边形
            })
            if (!item._controlsVisibility.forwardAddControl) {
                item.setControlsVisibility({
                    forwardAddControl: true
                })
                let newCoord = calcAddControlCoord(cList[item.cid == 0 ? (cList.length - 1) : (item.cid - 1)], cList[item.cid])
                //console.info(newCoord)
                item.controls.forwardAddControl.y = newCoord.y
                item.controls.forwardAddControl.x = newCoord.x
            }
            if (!item._controlsVisibility.backwardAddControl) {
                item.setControlsVisibility({
                    backwardAddControl: true
                })
                let newCoord = calcAddControlCoord(cList[item.cid == cList.length - 1 ? 0 : item.cid + 1], cList[item.cid])
                item.controls.backwardAddControl.y = newCoord.y
                item.controls.backwardAddControl.x = newCoord.x
            }
            item.bringToFront()
        })
        regionPoints = []
        rid = `region-${new Date().getTime()}`
    }

    function addPolygonToCanvas(vertexList, regionId) {
        //添加polyline
        // 多边形
        const polygon = new fabric.Polygon(
            vertexList, // 顶点坐标集
            {
                fill: POLYGON_FILL, // 填充
                stroke: 'black', // 边框黑色
                strokeWidth: 1, // 边框粗细
                objectCaching: false, // 当“true”时，对象缓存在另一个画布上。当“false”时，除非必要(clipPath)默认为 true，否则不缓存对象。默认是true
                //selectable: false, // 禁止选中
                //evented: false, // 当设置为“false”时，对象不能成为事件的目标。所有事件都会通过它传播。
                rid: regionId,
                // lockMovementX: true,
                // lockMovementY: true,
                lockRotation: true,
                lockScalingX: true,
                lockScalingY: true,
            }
        )
        fabricCanvas.add(polygon)

        let centerPoint = getPolygonCenter(vertexList)
        //console.info(centerPoint)
        //添加命名
        let text = new fabric.Text('区域' + regionId.substring(regionId.length - 3, regionId.length), {
            left: centerPoint.x,
            top: centerPoint.y,
            fontSize: 16,
            selectable: false,
            evented: false,
            rid: regionId,
        })
        fabricCanvas.add(text)
    }

    function addCircle(p, regionId, completedPolygon, spliceIndex) {
        let cid;
        if (spliceIndex != null) {
            if (!completedPolygon) {
                regionPoints.splice(spliceIndex, 0, p)
            }
            cid = spliceIndex
            //纠正后续cid
            fabricCanvas.getObjects('circle').filter(item => item.rid == regionId && item.cid >= spliceIndex).sort((a, b) => a.cid - b.cid).forEach(item => {
                item.cid += 1
            });
            //console.info(regionPoints)
        } else {
            regionPoints.push(p)
            cid = regionPoints.length - 1
        }
        let cc = new fabric.Circle({
            left: p.x,
            top: p.y,
            strokeWidth: 3,
            radius: CIRCLE_RADIUS,
            fill: '#fff',
            stroke: '#666',
            lockRotation: true,
            lockScalingX: true,
            lockScalingY: true,
            //transparentCorners: true,
            cornerStyle: 'rect',
            rid: regionId,
            tag: 'polygon-vertex',
            cid: cid,
            completedPolygon: completedPolygon//完成多边形
        })
        cc.controls = {
            deleteControl: new fabric.Control({
                x: 0,
                y: 0.4,
                offsetY: 16,
                cursorStyle: 'pointer',
                mouseUpHandler: deleteObject,
                render: renderIcon(deleteImg),
                cornerSize: 24
            }),
            backwardAddControl: new fabric.Control({
                x: 1.2,
                y: 0,
                cursorStyle: 'pointer',
                mouseUpHandler: addVertex,
                render: renderIcon(addImg),
                cornerSize: 24
            }),
            forwardAddControl: new fabric.Control({//Forward backward 向前添加
                x: -1.2,
                y: 0,
                cursorStyle: 'pointer',
                mouseUpHandler: addVertex,
                render: renderIcon(addImg),
                cornerSize: 24
            })
        }
        fabricCanvas.add(cc)
        if (!completedPolygon) {
            initCircleControlVisibility(regionId, true)
            if (regionPoints.length >= 3) {
                document.getElementById('btnCompleteRegion').disabled = false
            }
            if (regionPoints.length >= 2) {
                if (spliceIndex != null) {
                    //删除旧templine线
                    fabricCanvas.getObjects('line').filter(item => item.tag == 'tempLine' && item.index == spliceIndex - 1).forEach(item => {
                        fabricCanvas.remove(item)
                    })

                    //重新排序
                    fabricCanvas.getObjects('line').filter(item => item.tag == 'tempLine' && item.index >= spliceIndex).sort((a, b) => a.index - b.index).forEach(item => {
                        item.index++
                    })
                    //添加新线
                    addLine(regionPoints[spliceIndex - 1], regionPoints[spliceIndex], spliceIndex - 1)
                    addLine(regionPoints[spliceIndex], regionPoints[spliceIndex + 1], spliceIndex)

                } else {
                    addLine(regionPoints[regionPoints.length - 2], p, null)
                }
            }
        } else {
            cc.setControlsVisibility({
                forwardAddControl: true,
                backwardAddControl: true
            })
        }
    }

    //初始化圆圈contorl的显示隐藏
    function initCircleControlVisibility(regionId, checkVisiblity) {
        let cList = fabricCanvas.getObjects('circle').filter(item => item.rid == regionId).sort((a, b) => a.cid - b.cid);
        cList.forEach((item, index) => {
            if (checkVisiblity) {
                item.setControlsVisibility({
                    forwardAddControl: index != 0,
                    backwardAddControl: index != cList.length - 1
                })
            }
            if (index != cList.length - 1) {//向后
                let newCoord = calcAddControlCoord(cList[index + 1], cList[index])
                item.controls.backwardAddControl.y = newCoord.y
                item.controls.backwardAddControl.x = newCoord.x
            }
            if (index > 0) {//向前
                let newCoord = calcAddControlCoord(cList[index - 1], cList[index])
                item.controls.forwardAddControl.y = newCoord.y
                item.controls.forwardAddControl.x = newCoord.x
            }
        })
    }

    function calcAddControlCoord(p1, p2) {
        //console.info(p1, p2)
        let diffX, diffY;
        if (p1.x) {
            diffX = p1.x - p2.x
            diffY = p1.y - p2.y
        } else {
            diffX = p1.left - p2.left
            diffY = p1.top - p2.top
        }
        let _tan = Math.atan(diffX / diffY)
        let gamma = Math.round(Math.abs(_tan) * 180 / Math.PI)
        let sin = Math.sin(gamma * Math.PI / 180)
        let cos = Math.cos(gamma * Math.PI / 180)
        const c = 2.5
        let x = parseInt(c * sin * 10) / 10, y = parseInt(c * cos * 10) / 10
        //console.info(gamma, sin, x, y)
        if (diffX < 0) {
            x = -x
        }
        if (diffY < 0) {
            y = -y
        }
        return {x, y}
    }

    function addLine(p1, p2, index) {
        if (index == null) {
            index = fabricCanvas.getObjects('line').filter(item => item.tag == 'tempLine').length
        }
        let _line = new fabric.Line([p1.x, p1.y,
            p2.x, p2.y
        ], {
            stroke: 'black',
            selectable: false,
            tag: 'tempLine',
            index: index,
            evented: false,
        })
        fabricCanvas.add(_line)
    }

    function canvasMouseDown(opt) {
        let point = fabricCanvas.getPointer(opt.e)
        //console.info(point)
        if (regionAdding && currentActionType == 0) {
            addCircle(point, rid, false, null)
        } else if (currentActionType == 1 && opt.target == null) {
            let activePolygon = checkPolygonActive(point)
            if (activePolygon && arcuateLineAdding) {
                //添加圆
                console.info('添加圆')
                addCleanPathPoint(point, activePolygon.rid)
            }
        }
    }

    function checkPolygonActive(point) {
        let activePolygon = null;
        if (arcuateLineAdding) {
            activePolygon = fabricCanvas.getObjects('polygon').filter(fitem => fitem.active)[0]
            if (!rayCasting(point, activePolygon.points)) {
                activePolygon = null
                alert('请在选中的区域点击')
            }
        } else {
            fabricCanvas.getObjects('polygon').forEach(item => {
                if (rayCasting(point, item.points)) {
                    //console.info('containsPoint', point)
                    if (!item.active) {
                        let orgActivePolygon = fabricCanvas.getObjects('polygon').filter(fitem => fitem.active)[0]
                        if (orgActivePolygon) {
                            orgActivePolygon.set({
                                fill: POLYGON_FILL,
                                active: false
                            })
                        }
                        item.set({
                            fill: ACTIVE_POLYGON_FILL,
                            active: true
                        })
                        fabricCanvas.renderAll()
                    }
                    activePolygon = item
                }
            })
        }
        return activePolygon
    }

    /**
     * 获取多边形中心点
     * @param {Point[]} points 点坐标数组 [{x:0,y:0}...]
     */
    function getPolygonCenter(points) {
        if (!Array.isArray(points) || points.length < 3) {
            console.error("多边形坐标集合不能少于3个");
            return;
        }
        const result = {x: 0, y: 0};
        points.forEach((p) => {
            result.x += p.x;
            result.y += p.y;
        });
        result.x /= points.length;
        result.y /= points.length;
        return result;
    }


    function addArcuateLine() {
        if (fabricCanvas.getObjects('polygon').length == 0) {
            alert('请先添加区域')
            return
        }
        let activePolygon = fabricCanvas.getObjects('polygon').filter(fitem => fitem.active)[0]
        if (!activePolygon) {
            alert('请先选择区域')
            return
        }
        arcuateLineAdding = true
    }

    function regionCateClick(index, obj) {
        if (index == 1) {
            let len = fabricCanvas.getObjects('circle').filter(item => item.tag == 'polygon-vertex' && !item.completedPolygon).length
            if (len > 0) {
                alert('请先完成创建中的区域')
                return
            }
        }
        if (index == 0) {
            let len = fabricCanvas.getObjects('circle').filter(item => item.tag == 'arcuate-point').length
            if (len > 0) {
                alert('请先完成创建中的弓形线')
                return
            }
            arcuateLineAdding = false
        }
        fabricCanvas.discardActiveObject().renderAll();

        currentActionType = index
        let domList = document.querySelectorAll('.left-cate div')
        //console.info(domList)
        for (let i = 0; i < domList.length; i++) {
            if (index == i) {
                domList[i].classList.add('active')
            } else {
                domList[i].classList.remove('active')
            }
        }


        let topDomList = document.querySelectorAll('.top-group div')
        for (let i = 0; i < topDomList.length; i++) {
            if (index == i) {
                topDomList[index].classList.remove('dis-none')
            } else {
                topDomList[i].classList.add('dis-none')
            }
        }

        fabricCanvas.getObjects('circle').filter(item => item.tag == 'polygon-vertex').forEach(item => {
            item.set({
                evented: index == 0
            })
        })
        fabricCanvas.getObjects('polygon').forEach(item => {
            item.set({
                evented: index == 0
            })
        })
        if (index == 0) {
            fabricCanvas.getObjects('polygon').forEach(item => {
                item.set({
                    fill: POLYGON_FILL,
                    active: false
                })
            })
            fabricCanvas.renderAll()
        }
    }

    /**
     * @description 射线法判断点是否在多边形内部
     * @param {Object} p 待判断的点，格式：{ x: X坐标, y: Y坐标 }
     * @param {Array} poly 多边形顶点，数组成员的格式同 p
     * @return {String} 点 p 和多边形 poly 的几何关系
     */
    function rayCasting(p, poly) {
        var px = p.x,
            py = p.y,
            flag = false

        for (var i = 0, l = poly.length, j = l - 1; i < l; j = i, i++) {
            var sx = poly[i].x,
                sy = poly[i].y,
                tx = poly[j].x,
                ty = poly[j].y

            // 点与多边形顶点重合
            if ((sx === px && sy === py) || (tx === px && ty === py)) {
                return false //'on'
            }

            // 判断线段两端点是否在射线两侧
            if ((sy < py && ty >= py) || (sy >= py && ty < py)) {
                // 线段上与射线 Y 坐标相同的点的 X 坐标
                var x = sx + (py - sy) * (tx - sx) / (ty - sy)

                // 点在多边形的边上
                if (x === px) {
                    return false //'on'
                }

                // 射线穿过多边形的边界
                if (x > px) {
                    flag = !flag
                }
            }
        }

        // 射线穿过多边形边界的次数为奇数时点在多边形内
        return flag //? 'in' : 'out'
    }

    /**
     * 添加清洁路径点
     * @param p
     * @param regionId
     */
    function addCleanPathPoint(p, regionId, index) {
        let pList = fabricCanvas.getObjects('circle').filter(item => item.tag == 'arcuate-point' && item.rid == regionId)
        if (pList.length == 2) {
            //画弓形线
            arcuateLineAdding = false
            console.info(arcuateLineAdding, pList, p)
            let points = []
            pList.forEach(item => {
                points.push({
                    x: item.left,
                    y: item.top
                })
                fabricCanvas.remove(item)
            })
            points.push(p)
            drawArcuateLine(points, regionId)
            return
        }

        let cc = new fabric.Circle({
            left: p.x,
            top: p.y,
            strokeWidth: 3,
            radius: CIRCLE_RADIUS,
            fill: '#fff',
            stroke: '#21378d',
            lockRotation: true,
            lockScalingX: true,
            lockScalingY: true,
            cornerStyle: 'rect',
            rid: regionId,
            tag: 'arcuate-point',//弓形线点
        })
        cc.controls = {
            deleteControl: new fabric.Control({
                x: 0,
                y: 0.4,
                offsetY: 16,
                cursorStyle: 'pointer',
                mouseUpHandler: deleteObject,
                render: renderIcon(deleteImg),
                cornerSize: 24
            })
        }
        fabricCanvas.add(cc)

    }

    /***
     * 画弓形线
     * @param pList
     * @param regionId
     */
    function drawArcuateLine(pointList, regionId) {
        console.info(pointList, regionId)
        let diffX = pointList[0].x - pointList[1].x, diffY = pointList[0].y - pointList[1].y
        let c = Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2))
        let sina = Math.abs(diffX) / c, sinb = Math.abs(diffY) / c;
        let stepY = cleanWidth * sina, stepX = cleanWidth * sinb;
        if (pointList[0].x > pointList[1].x) {
            if (pointList[0].y > pointList[1].y) {
                if (pointList[2].y > pointList[0].y) {
                    stepX = -stepX
                } else {
                    stepY = -stepY
                }
            } else {
                if (pointList[2].y < pointList[1].y) {
                    stepX = -stepX
                    stepY = -stepY
                }
            }
        } else {
            if (pointList[0].y > pointList[1].y) {
                if (pointList[2].y < pointList[0].y) {
                    stepX = -stepX
                    stepY = -stepY
                }
            } else {
                if (pointList[2].y > pointList[1].y) {
                    stepX = -stepX
                } else {
                    stepY = -stepY
                }
            }
        }
        let verticalDis = getDis(pointList[0], pointList[1], pointList[2])
        console.info(stepX, stepY, verticalDis, verticalDis / cleanWidth)
        let inflectionCount = Math.round(verticalDis / cleanWidth) + 1//拐线数量
        let polylinePoint = []
        for (let i = 0; i < inflectionCount; i++) {
            if (i % 2 == 0) {
                polylinePoint.push({
                    x: Math.round(pointList[0].x + stepX * i),
                    y: Math.round(pointList[0].y + stepY * i),
                })
                polylinePoint.push({
                    x: Math.round(pointList[1].x + stepX * i),
                    y: Math.round(pointList[1].y + stepY * i),
                })
            } else {
                polylinePoint.push({
                    x: Math.round(pointList[1].x + stepX * i),
                    y: Math.round(pointList[1].y + stepY * i),
                })
                polylinePoint.push({
                    x: Math.round(pointList[0].x + stepX * i),
                    y: Math.round(pointList[0].y + stepY * i),
                })
            }
        }
        console.info(polylinePoint)
        let polyline = new fabric.Polyline(polylinePoint, {
            fill: 'transparent',
            stroke: '#6639a6',
            strokeWidth: 1,
            strokeDashArray: [10, 7],
            lockScalingX: true,
            lockScalingY: true
        })
        fabricCanvas.add(polyline)

        const callback = (image, isError) => {
            image.scale(0.3)
            image.set({
                left: polylinePoint[0].x - 5,
                top: polylinePoint[0].y - 5,
                evented: false,
            })
            fabricCanvas.add(image);
        };
        fabric.Image.fromURL(starImg, callback)

        const callback2 = (image, isError) => {
            image.scale(0.3)
            image.set({
                left: polylinePoint[polylinePoint.length-1].x - 5,
                top: polylinePoint[polylinePoint.length-1].y - 5,
                evented: false,
            })
            fabricCanvas.add(image);
        };
        fabric.Image.fromURL(endImg, callback2)
    }

    //由2点确定的直线，求到第三点的距离
    function getDis(p1, p2, p3) {
        var len;
        //如果p1.x==p2.x 说明是条竖着的线
        if (p1.x - p2.x == 0) {
            len = Math.abs(p3.x - p1.x)
        } else {
            var A = (p1.y - p2.y) / (p1.x - p2.x)
            var B = p1.y - A * p1.x

            len = Math.abs((A * p3.x + B - p3.y) / Math.sqrt(A * A + 1))
        }
        return len
    }

</script>